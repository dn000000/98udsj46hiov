# Вербальная модель алгоритма поиска пути BFS

## Описание алгоритма

Алгоритм поиска в ширину (BFS - Breadth-First Search) - это метод обхода графа, при котором сначала исследуются все вершины, находящиеся на одинаковом расстоянии от начальной вершины, прежде чем перейти к вершинам, находящимся на большем расстоянии.

В контексте задачи поиска пути в лабиринте алгоритм BFS гарантирует нахождение кратчайшего пути от начальной точки до конечной (если такой путь существует).

## Словесное описание алгоритма

1. **Инициализация**:
   - Определяем начальную позицию (стартовую точку) и конечную позицию (целевую точку) в лабиринте.
   - Создаем пустую очередь для хранения позиций, которые нужно исследовать.
   - Помещаем начальную позицию в очередь.
   - Создаем словарь посещенных позиций, в котором для каждой позиции будем хранить позицию, из которой мы в нее попали.
   - Отмечаем начальную позицию как посещенную, устанавливая для нее в словаре значение `None` (так как в начальную позицию мы не попадали ниоткуда).

2. **Основной цикл**:
   - Пока очередь не пуста:
     - Извлекаем первую позицию из очереди (текущую позицию).
     - Если текущая позиция является конечной:
       - Заканчиваем поиск и переходим к восстановлению пути.
     - Иначе:
       - Для каждого соседа текущей позиции (верх, низ, влево, вправо):
         - Если сосед является допустимой позицией (не стена, в пределах лабиринта) и еще не был посещен:
           - Добавляем соседа в конец очереди.
           - Отмечаем соседа как посещенного, сохраняя в словаре ссылку на текущую позицию.

3. **Восстановление пути**:
   - Если мы достигли конечной позиции:
     - Начинаем с конечной позиции.
     - Используя словарь посещенных позиций, последовательно восстанавливаем путь от конечной позиции к начальной.
     - Переворачиваем полученный путь, чтобы он шел от начальной позиции к конечной.
   - Если очередь опустела, а мы не достигли конечной позиции:
     - Путь не существует.

4. **Результат**:
   - Возвращаем список позиций, представляющих путь от начальной до конечной точки, или `None`, если путь не найден.

## Основные преимущества алгоритма BFS

1. **Гарантия кратчайшего пути**: В невзвешенном графе (или лабиринте, где все шаги имеют одинаковую стоимость) BFS всегда находит кратчайший путь.
2. **Полнота**: Если путь существует, BFS гарантированно его найдет.
3. **Оптимальность**: Найденный путь будет кратчайшим с точки зрения количества шагов.

## Сложность алгоритма

- **Временная сложность**: O(V + E), где V - количество вершин (клеток лабиринта), E - количество ребер (соединений между клетками). В худшем случае алгоритм посетит все клетки лабиринта.
- **Пространственная сложность**: O(V), так как нам нужно хранить очередь и словарь посещенных позиций, размер которых пропорционален количеству вершин.

## Применимость к задаче

Алгоритм BFS идеально подходит для поиска кратчайшего пути в лабиринте, где все шаги имеют одинаковую стоимость. Он гарантирует нахождение пути с минимальным количеством шагов, если такой путь существует. 