# Алгоритм поиска пути с учетом типов местности (Dijkstra)

## Описание алгоритма

Алгоритм Дейкстры (Dijkstra) - это метод поиска кратчайшего пути во взвешенном графе, где вес рёбер может быть различным. В контексте проекта PathFinder этот алгоритм используется для нахождения оптимального пути с учетом различных типов местности, где каждый тип имеет свою стоимость прохода.

В отличие от алгоритма BFS, который находит путь с минимальным количеством шагов (когда все шаги имеют одинаковую стоимость), алгоритм Дейкстры находит путь с минимальной суммарной стоимостью, учитывая различные затраты на преодоление разных типов местности.

## Типы местности и их стоимость

| Символ | Тип местности | Стоимость прохода |
|--------|--------------|-------------------|
| `R`    | Road (Дорога) | 0.5              |
| `G`    | Grass (Поле)  | 1                |
| `F`    | Forest (Лес)  | 3                |
| `H`    | Hill (Холмы)  | 4                |
| `S`    | Swamp (Болото)| 5                |
| `W`    | Water (Вода)  | ∞ (нет прохода)  |
| `M`    | Mountain (Горы)| ∞ (нет прохода) |

## Словесное описание алгоритма

1. **Инициализация**:
   - Определяем начальную позицию (стартовую точку) и конечную позицию (целевую точку).
   - Создаем словарь расстояний, где для каждой позиции хранится минимальная стоимость пути от начальной позиции. Изначально для всех позиций, кроме начальной, расстояние устанавливается равным бесконечности.
   - Расстояние до начальной позиции устанавливается равным 0.
   - Создаем очередь с приоритетами, где приоритет определяется текущей стоимостью пути до позиции.
   - Помещаем начальную позицию в очередь с приоритетом 0.
   - Создаем словарь посещенных позиций, в котором для каждой позиции будем хранить позицию, из которой мы в нее попали.

2. **Основной цикл**:
   - Пока очередь не пуста:
     - Извлекаем позицию с минимальным расстоянием из очереди (текущую позицию).
     - Если текущая позиция является конечной:
       - Заканчиваем поиск и переходим к восстановлению пути.
     - Иначе:
       - Для каждого соседа текущей позиции:
         - Если сосед является проходимой позицией:
           - Вычисляем новое расстояние до соседа как сумму расстояния до текущей позиции и стоимости прохода через соседа.
           - Если новое расстояние меньше, чем ранее вычисленное расстояние до соседа:
             - Обновляем расстояние до соседа.
             - Обновляем предыдущую позицию для соседа.
             - Добавляем соседа в очередь с новым приоритетом.

3. **Восстановление пути**:
   - Если мы достигли конечной позиции:
     - Начинаем с конечной позиции.
     - Используя словарь посещенных позиций, последовательно восстанавливаем путь от конечной позиции к начальной.
     - Переворачиваем полученный путь, чтобы он шел от начальной позиции к конечной.
   - Если очередь опустела, а мы не достигли конечной позиции:
     - Путь не существует.

4. **Результат**:
   - Возвращаем список позиций, представляющих оптимальный путь от начальной до конечной точки, или `None`, если путь не найден.

## Математическая модель

### Входные данные:
- Граф $G = (V, E)$, где $V$ - множество вершин (клетки лабиринта), а $E$ - множество ребер (переходы между соседними клетками).
- Функция веса $w: E \rightarrow \mathbb{R}^+$, которая для каждого ребра $(u, v) \in E$ возвращает стоимость перехода из $u$ в $v$.
- Начальная вершина $s \in V$.
- Целевая вершина $t \in V$.

### Выходные данные:
- Кратчайший путь от $s$ до $t$ с учетом весов ребер, если такой путь существует.

### Определения:
- $d[v]$ - текущая минимальная стоимость пути от $s$ до $v$.
- $\pi[v]$ - предыдущая вершина на текущем кратчайшем пути от $s$ до $v$.
- $Q$ - приоритетная очередь вершин, упорядоченная по возрастанию $d[v]$.

### Алгоритм:

1. **Инициализация**:
   $$\forall v \in V: d[v] \leftarrow \infty, \pi[v] \leftarrow \text{null}$$
   $$d[s] \leftarrow 0$$
   $$Q \leftarrow V$$

2. **Основной цикл**:
   Пока $Q \neq \emptyset$:
   - $u \leftarrow \text{ExtractMin}(Q)$ (извлечь вершину с минимальным значением $d[u]$)
   - Если $u = t$, то завершить алгоритм
   - Для каждого соседа $v$ вершины $u$:
     - Если $v$ является проходимой позицией:
       - $\text{relax}(u, v, w)$:
         - Если $d[v] > d[u] + w(u, v)$, то:
           - $d[v] \leftarrow d[u] + w(u, v)$
           - $\pi[v] \leftarrow u$
           - Обновить положение $v$ в очереди $Q$

3. **Восстановление пути**:
   - Если $d[t] < \infty$ (путь существует):
     - $P \leftarrow [t]$
     - Пока $\pi[P_{\text{head}}] \neq \text{null}$:
       - $P \leftarrow [\pi[P_{\text{head}}]] + P$
     - Вернуть $P$
   - Иначе вернуть "Путь не существует"

## Сложность алгоритма

- **Временная сложность**: $O((|V| + |E|) \log |V|)$ при использовании очереди с приоритетами на основе двоичной кучи.
- **Пространственная сложность**: $O(|V|)$ для хранения расстояний, предыдущих вершин и очереди.

## Преимущества и отличия от BFS

1. **Учет стоимости**: В отличие от BFS, алгоритм Дейкстры учитывает различные стоимости перехода, что позволяет находить оптимальный путь с минимальной суммарной стоимостью, а не просто с минимальным количеством шагов.

2. **Применимость**: Алгоритм Дейкстры применим к графам с неотрицательными весами ребер, что идеально подходит для задачи поиска пути в лабиринте с различными типами местности.

3. **Гибкость**: Алгоритм легко адаптируется к изменениям в стоимости прохода для разных типов местности.

## Пример использования

```python
from terrain_maze import TerrainMaze
from terrain_pathfinder import TerrainPathFinder
from terrain_visualizer import TerrainVisualizer

# Создаем лабиринт с разными типами местности
maze = TerrainMaze(grid=[
    "##########",
    "#SRG.FGHR#",
    "#.#####.##",
    "#HRGFS..F#",
    "#.####.###",
    "#HRFGFG.E#",
    "##########"
])

# Создаем объект для поиска пути
pathfinder = TerrainPathFinder(maze)

# Ищем путь с учетом стоимости перемещения
path = pathfinder.dijkstra()

# Вычисляем стоимость пути
path_cost = pathfinder.get_path_cost(path)
print(f"Общая стоимость пути: {path_cost}")

# Получаем направления движения с учетом стоимости
directions = pathfinder.get_path_directions_with_costs(path)
for direction, cost in directions:
    print(f"{direction}: {cost}")

# Визуализируем путь
visualizer = TerrainVisualizer(maze)
visualizer.display_path(path)
```

В данном примере мы создаем лабиринт с различными типами местности, находим оптимальный путь с учетом стоимости прохода через каждый тип местности, вычисляем общую стоимость пути и визуализируем результат. 