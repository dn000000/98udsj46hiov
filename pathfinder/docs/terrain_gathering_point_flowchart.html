<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Блок-схема алгоритма поиска оптимальной точки сбора</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            padding: 0;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .description {
            margin-bottom: 30px;
        }
        .mermaid {
            margin: 20px 0;
        }
        .note {
            background-color: #f8f9fa;
            border-left: 4px solid #28a745;
            padding: 10px 20px;
            margin: 20px 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Блок-схема алгоритма поиска оптимальной точки сбора</h1>
        
        <div class="description">
            <p>
                Данная блок-схема демонстрирует алгоритм поиска оптимальной точки сбора для героев с учетом 
                различных типов местности и скоростей передвижения героев.
            </p>
        </div>

        <h2>Типы местности и их стоимость</h2>
        <table>
            <tr>
                <th>Символ</th>
                <th>Тип местности</th>
                <th>Стоимость прохода</th>
            </tr>
            <tr>
                <td>R</td>
                <td>Road (Дорога)</td>
                <td>0.5</td>
            </tr>
            <tr>
                <td>G</td>
                <td>Grass (Поле)</td>
                <td>1</td>
            </tr>
            <tr>
                <td>F</td>
                <td>Forest (Лес)</td>
                <td>3</td>
            </tr>
            <tr>
                <td>H</td>
                <td>Hill (Холмы)</td>
                <td>4</td>
            </tr>
            <tr>
                <td>S</td>
                <td>Swamp (Болото)</td>
                <td>5</td>
            </tr>
            <tr>
                <td>W</td>
                <td>Water (Вода)</td>
                <td>∞ (нет прохода)</td>
            </tr>
            <tr>
                <td>M</td>
                <td>Mountain (Горы)</td>
                <td>∞ (нет прохода)</td>
            </tr>
        </table>

        <h2>Формула расчета времени прибытия</h2>
        <p>
            Время прибытия героя с позиции \(h_i\) со скоростью \(s_i\) в точку \(p\) рассчитывается как:
            $$t(h_i, p, s_i) = \frac{d(h_i, p)}{s_i}$$
            где \(d(h_i, p)\) - минимальная стоимость пути от позиции героя до точки \(p\).
        </p>

        <h2>Блок-схема алгоритма</h2>
        
        <div class="mermaid">
            graph TD
                A[Начало] --> B[Входные данные:<br>1. Позиции героев<br>2. Скорости героев<br>3. Карта с типами местности]
                
                B --> C[Для каждого героя вычислить расстояния<br>до всех достижимых точек<br>с учетом стоимости местности<br>используя алгоритм Дейкстры]
                
                C --> D[Для каждой точки и каждого героя<br>вычислить время прибытия:<br>время = расстояние / скорость героя]
                
                D --> E[Для каждой точки найти<br>максимальное время прибытия<br>среди всех героев]
                
                E --> F[Выбрать точку с минимальным<br>максимальным временем прибытия]
                
                F --> G[Построить оптимальные пути<br>от каждого героя до выбранной точки]
                
                G --> H[Вычислить время прибытия<br>для каждого героя в выбранную точку]
                
                H --> I[Вернуть результат:<br>1. Оптимальная точка сбора<br>2. Время прибытия для каждого героя<br>3. Пути от героев до точки сбора]
                
                I --> J[Конец]
        </div>

        <h2>Детализированный процесс поиска оптимальной точки</h2>
        
        <div class="mermaid">
            graph TD
                A[Начать поиск оптимальной точки] --> B[Инициализировать:<br>best_point = null<br>min_max_time = бесконечность]
                
                B --> C[Для каждой проходимой<br>точки p на карте]
                
                C --> D{Все точки<br>обработаны?}
                D --Да--> E[Вернуть best_point]
                D --Нет--> F[Проверить следующую точку p]
                
                F --> G{Точка p достижима<br>от всех героев?}
                G --Нет--> C
                G --Да--> H[Для каждого героя hi со скоростью si<br>вычислить время прибытия в точку p:<br>t_i = d_i / s_i]
                
                H --> I[Найти максимальное время прибытия<br>max_time = max t_i]
                
                I --> J{max_time < min_max_time?}
                J --Нет--> C
                J --Да--> K[Обновить:<br>min_max_time = max_time<br>best_point = p]
                
                K --> C
                
                E --> L[Конец]
        </div>

        <div class="note">
            <h3>Примечание:</h3>
            <p>Этот алгоритм является расширением базового алгоритма поиска равноудаленной точки. Вместо минимизации максимального
            расстояния, он минимизирует максимальное время прибытия, учитывая различные типы местности и скорости героев.
            Это дает более реалистичный результат для сценариев с разными скоростями и типами местности.</p>
        </div>

        <h2>Оптимизации алгоритма</h2>
        
        <div class="mermaid">
            graph TD
                A[Начало оптимизаций] --> B[Ранний останов:<br>Если найдена точка с одинаковым<br>временем прибытия для всех героев<br>и это время меньше порога,<br>прекратить поиск]
                
                B --> C[Пропуск недостижимых точек:<br>Точки, недостижимые хотя бы<br>от одного героя, исключаются<br>из рассмотрения]
                
                C --> D[Ограничение области поиска:<br>Если есть предварительная оценка<br>времени прибытия, ограничить<br>область поиска точками,<br>которые потенциально<br>могут дать лучший результат]
                
                D --> E[Конец оптимизаций]
        </div>

        <script>
            mermaid.initialize({
                startOnLoad: true,
                theme: 'default',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true,
                    curve: 'basis'
                }
            });
        </script>
    </div>
</body>
</html>
