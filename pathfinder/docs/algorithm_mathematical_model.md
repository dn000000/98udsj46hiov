# Математическая модель алгоритма поиска пути BFS

## Формальное описание алгоритма

Алгоритм поиска в ширину (BFS) можно формально описать следующим образом:

### Входные данные:
- Граф $G = (V, E)$, где $V$ - множество вершин, а $E$ - множество ребер.
- Начальная вершина $s \in V$.
- Целевая вершина $t \in V$.

### Выходные данные:
- Кратчайший путь от $s$ до $t$, если такой путь существует.
- Сообщение об отсутствии пути, если путь не существует.

### Определения:
- $Q$ - очередь вершин для обхода.
- $visited$ - множество посещенных вершин.
- $parent$ - словарь, где $parent[v]$ - это вершина, из которой мы пришли в вершину $v$.
- $Adj(v)$ - множество соседних вершин для вершины $v$.

### Алгоритм:

1. **Инициализация**:
   $$Q \leftarrow \{s\}$$
   $$visited \leftarrow \{s\}$$
   $$parent[s] \leftarrow null$$

2. **Основной цикл**:
   Пока $Q \neq \emptyset$:
   - $v \leftarrow$ первый элемент из $Q$
   - Удалить $v$ из $Q$
   - Если $v = t$, то:
     - Восстановить путь, используя $parent$, и вернуть его
   - Иначе:
     - Для каждой вершины $u \in Adj(v)$:
       - Если $u \notin visited$, то:
         - $visited \leftarrow visited \cup \{u\}$
         - $parent[u] \leftarrow v$
         - Добавить $u$ в конец $Q$

3. **Восстановление пути**:
   Если $t \in visited$:
   - $path \leftarrow []$
   - $current \leftarrow t$
   - Пока $current \neq null$:
     - Добавить $current$ в начало $path$
     - $current \leftarrow parent[current]$
   - Вернуть $path$
   Иначе:
   - Вернуть сообщение "Путь не существует"

## Корректность алгоритма

### Утверждение:
Если существует путь от $s$ до $t$, то алгоритм BFS найдет кратчайший такой путь.

### Доказательство:

1. **Достижение цели**:
   - Если существует путь от $s$ до $t$, то вершина $t$ будет добавлена в очередь $Q$ и обработана на некотором шаге алгоритма.
   - Это следует из полноты обхода: BFS обходит все вершины, достижимые из $s$.

2. **Кратчайший путь**:
   - Пусть $d(s, v)$ - длина кратчайшего пути от $s$ до $v$.
   - Утверждение: Для любой вершины $v$, к моменту, когда $v$ извлекается из очереди $Q$, путь, восстановленный с помощью $parent$, имеет длину $d(s, v)$.
   
   Доказательство по индукции по $d(s, v)$:
   - База индукции: $d(s, s) = 0$. Очевидно, что путь от $s$ до $s$ имеет длину 0.
   - Индукционный переход: Предположим, что утверждение верно для всех вершин $u$ с $d(s, u) \leq k$. Рассмотрим вершину $v$ с $d(s, v) = k+1$.
     - Существует вершина $u$, такая что $d(s, u) = k$ и $(u, v) \in E$.
     - По индукционному предположению, $u$ извлекается из $Q$ с правильным кратчайшим путем до нее.
     - Когда $u$ обрабатывается, $v$ добавляется в $Q$ (если еще не была добавлена).
     - Если $v$ еще не была посещена, то $parent[v] = u$, и путь до $v$ имеет длину $k+1 = d(s, v)$.
     - Если $v$ уже была посещена, то она была добавлена в $Q$ через другую вершину $u'$ с $d(s, u') \leq k$. Но тогда $d(s, v) \leq d(s, u') + 1 \leq k + 1$, что не противоречит условию $d(s, v) = k+1$.

Таким образом, когда алгоритм находит вершину $t$, путь, восстановленный с помощью $parent$, имеет длину $d(s, t)$, то есть является кратчайшим.

## Сложность алгоритма

### Временная сложность:
- Инициализация: $O(1)$
- Основной цикл: Каждая вершина добавляется в очередь $Q$ не более одного раза, и каждое ребро рассматривается не более одного раза.
  - Стоимость обработки всех вершин: $O(|V|)$
  - Стоимость обработки всех ребер: $O(|E|)$
- Итого: $O(|V| + |E|)$

### Пространственная сложность:
- Очередь $Q$: В худшем случае может содержать все вершины графа, то есть $O(|V|)$.
- Множество $visited$: $O(|V|)$
- Словарь $parent$: $O(|V|)$
- Итого: $O(|V|)$

## Применение к задаче поиска пути в лабиринте

В контексте лабиринта:
- Вершины $V$ - это клетки лабиринта.
- Ребра $E$ - это возможные переходы между соседними клетками (клетки, которые не являются стенами).
- Начальная вершина $s$ - это начальная позиция.
- Целевая вершина $t$ - это конечная позиция.

Алгоритм BFS гарантированно найдет кратчайший путь от начальной до конечной позиции, если такой путь существует. 