# Алгоритм поиска оптимальной точки сбора с учетом типов местности

## Описание алгоритма

Алгоритм поиска оптимальной точки сбора для героев с учетом типов местности - это расширение базового алгоритма поиска равноудаленной точки. В отличие от базового алгоритма, который минимизирует максимальное количество шагов для всех героев, этот алгоритм учитывает различные типы местности и скорости героев для нахождения такой точки, в которой все герои соберутся как можно раньше.

Алгоритм принимает во внимание, что герои могут передвигаться с разной скоростью по разным типам местности, и ищет точку с минимальным максимальным временем прибытия для всех героев.

## Формулировка задачи

Дана карта мира с разными типами местности, каждый из которых имеет свою стоимость прохода. На карте находятся несколько героев, каждый может иметь свою скорость передвижения. Требуется найти такую точку сбора, что:

1. Она достижима от всех героев (существует проходимый путь).
2. Время прибытия всех героев в эту точку будет минимальным (минимизируется максимальное время прибытия).

## Типы местности и их стоимость прохода

| Символ | Тип местности | Стоимость прохода |
|--------|--------------|-------------------|
| `R`    | Road (Дорога) | 0.5              |
| `G`    | Grass (Поле)  | 1                |
| `F`    | Forest (Лес)  | 3                |
| `H`    | Hill (Холмы)  | 4                |
| `S`    | Swamp (Болото)| 5                |
| `W`    | Water (Вода)  | ∞ (нет прохода)  |
| `M`    | Mountain (Горы)| ∞ (нет прохода) |

## Скорости героев

Герои могут передвигаться с разной базовой скоростью, которая влияет на время прохода через различные типы местности. Например:

- Быстрый герой: скорость 2.0 (в два раза быстрее стандартной)
- Стандартный герой: скорость 1.0
- Медленный герой: скорость 0.5 (в два раза медленнее стандартной)

## Словесное описание алгоритма

1. **Предварительный этап**:
   - Принимаем на вход позиции героев и их скорости.
   - Определяем все достижимые позиции в лабиринте.

2. **Вычисление расстояний с учетом стоимости**:
   - Для каждого героя:
     - Вычисляем расстояния до всех достижимых точек с учетом стоимости перехода по разным типам местности (используя алгоритм Дейкстры).
     - Сохраняем эти расстояния в структуре данных.

3. **Вычисление времени прибытия**:
   - Для каждой точки и каждого героя:
     - Вычисляем время прибытия как отношение расстояния (стоимости пути) к скорости героя.
     - Сохраняем эти времена.

4. **Поиск оптимальной точки сбора**:
   - Для каждой достижимой точки:
     - Находим максимальное время прибытия среди всех героев.
   - Выбираем точку с минимальным максимальным временем прибытия.

5. **Построение путей**:
   - Для найденной оптимальной точки сбора:
     - Для каждого героя строим оптимальный путь до этой точки.
     - Вычисляем время прибытия каждого героя.

6. **Результат**:
   - Возвращаем найденную оптимальную точку сбора, время прибытия для каждого героя и пути от героев до этой точки.

## Математическая модель

### Определения:
- Пусть $H = \{h_1, h_2, ..., h_n\}$ - множество позиций героев, где $n \geq 2$.
- Пусть $S = \{s_1, s_2, ..., s_n\}$ - соответствующие скорости героев.
- Пусть $M$ - множество всех проходимых точек в лабиринте.
- Для героя $h_i$ со скоростью $s_i$ и точки $p \in M$, определим время прибытия $t(h_i, p, s_i) = \frac{d(h_i, p)}{s_i}$, где $d(h_i, p)$ - минимальная стоимость пути от $h_i$ до $p$.
- Для каждой точки $p \in M$ определим максимальное время прибытия: $T(p) = \max\limits_{i=1}^{n} t(h_i, p, s_i)$.

### Задача:
Найти такую точку $p^* \in M$, что $T(p^*)$ минимально, т.е. $p^* = \arg\min\limits_{p \in M} T(p)$.

### Алгоритм:

1. **Инициализация**:
   - Для каждого героя $h_i$ со скоростью $s_i$ и для каждой точки $p \in M$:
     - Вычисляем $d(h_i, p)$ с использованием алгоритма Дейкстры.
     - Вычисляем время прибытия $t(h_i, p, s_i) = \frac{d(h_i, p)}{s_i}$.

2. **Поиск оптимальной точки**:
   - Для каждой точки $p \in M$:
     - Вычисляем $T(p) = \max\limits_{i=1}^{n} t(h_i, p, s_i)$.
   - Находим $p^* = \arg\min\limits_{p \in M} T(p)$.

3. **Результат**:
   - Возвращаем $p^*$ как оптимальную точку сбора.
   - Для каждого героя $h_i$ строим оптимальный путь до $p^*$.
   - Вычисляем время прибытия $t(h_i, p^*, s_i)$ для каждого героя.

## Сложность алгоритма

- **Временная сложность**: $O(n \cdot |M| \cdot log|M|)$, где $n$ - количество героев, $|M|$ - количество точек в лабиринте. Эта сложность обусловлена тем, что для каждого героя мы запускаем алгоритм Дейкстры (стоимостью $O(|M| \cdot log|M|)$).
- **Пространственная сложность**: $O(n \cdot |M|)$ для хранения расстояний и времен прибытия.

## Оптимизации

1. **Ранний останов**: Если время прибытия в некоторую точку для всех героев равно, и это время меньше некоторого порога, мы можем прекратить поиск, так как нашли идеальное решение.

2. **Пропуск недостижимых точек**: Точки, недостижимые хотя бы от одного героя, исключаются из рассмотрения.

3. **Ограничение области поиска**: Если у нас есть предварительная оценка времени прибытия, мы можем ограничить область поиска только теми точками, которые потенциально могут дать лучший результат.

## Пример использования

```python
from terrain_maze import TerrainMaze
from terrain_equidistant_finder import TerrainEquidistantFinder
from terrain_visualizer import TerrainVisualizer

# Создаем лабиринт с разными типами местности
maze = TerrainMaze(grid=[
    "##########",
    "#1RG.FGH.#",
    "#.#####.##",
    "#HRGFS..F#",
    "#.####.###",
    "#H.FGFG.2#",
    "##########"
])

# Определяем позиции и скорости героев
hero_positions = [(1, 1), (8, 5)]  # Позиции героев (в символах '1' и '2')
hero_speeds = [1.0, 0.5]  # Скорости героев: первый - стандартный, второй - медленный

# Создаем объект для поиска оптимальной точки сбора
finder = TerrainEquidistantFinder(maze)

# Ищем оптимальную точку сбора
gathering_point = finder.find_optimal_gathering_point(hero_positions, hero_speeds)

# Получаем время прибытия для каждого героя
arrival_times = finder.get_arrival_times(gathering_point, hero_positions, hero_speeds)
for i, time in enumerate(arrival_times):
    print(f"Герой {i+1} прибудет через {time:.2f} единиц времени")

# Получаем максимальное время прибытия
max_time = finder.get_max_arrival_time(gathering_point, hero_positions, hero_speeds)
print(f"Все герои соберутся через {max_time:.2f} единиц времени")

# Визуализируем оптимальную точку сбора и пути героев
visualizer = TerrainVisualizer(maze)
visualizer.display_gathering_point(hero_positions, gathering_point, hero_speeds)
```

В этом примере мы создаем лабиринт с различными типами местности, определяем позиции и скорости героев, находим оптимальную точку сбора, вычисляем время прибытия для каждого героя и визуализируем результат.

## Отличия от базового алгоритма поиска равноудаленной точки

1. **Учет стоимости местности**: В отличие от базового алгоритма, который учитывает только количество шагов, новый алгоритм принимает во внимание стоимость прохода через разные типы местности.

2. **Учет скоростей героев**: Новый алгоритм учитывает, что герои могут передвигаться с разной скоростью, что влияет на их время прибытия.

3. **Оптимизация по времени**: Алгоритм минимизирует максимальное время прибытия, а не максимальное расстояние, что дает более реалистичный результат для сценариев с разными скоростями и типами местности.

4. **Сложность вычислений**: Новый алгоритм использует алгоритм Дейкстры вместо BFS для вычисления расстояний, что увеличивает вычислительную сложность, но позволяет учесть различные стоимости перехода. 